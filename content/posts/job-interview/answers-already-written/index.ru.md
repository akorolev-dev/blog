---
title: "Все ответы уже давно написаны"
date: 2024-03-03T07:21:13+04:00
draft: false
description: "Пример из опыта прохождения собеседования, что даже неоднократно написанное стоит всегда проверять."
noindex: false
featured: true
pinned: false
comments: true
slug: answers-already-written
series:
  - job-interview
categories:
  - education
  - reflections
tags:
  - java
images:
  - steve-johnson-y-mB90P-6DY-unsplash.jpg
---

Примерно с такой фразы началась техническая часть одного из моих собеседований.
После очередной затяжки электронной сигареты собеседующий прислал ссылку.

В целом, крупный российский биржевой холдинг может себе позволить "лайвкодинг в блокноте", о котором ведется множество
дебатов в последнее время.
А вот человек, покуривающий на фоне интернет-мема "Ни~~х**~~ не понял, но очень интересно.", и до этого момента вызывал
сугубо желание завершить встречу досрочно.
Но работая в компании, которая всем сердцем полюбила {{< abbr "аутстаффинг" >}}, приходится в итоге действовать немного
иначе.

Что же, отбросим лирику и перейдем к сути статьи.
Как точно выглядел код для "расскажите, какой тут будет вывод" я уже не помню, но смысл был примерно следующий:

```java
Integer a = new Integer(127);
Integer b = 127;
Integer c = 127;

Integer d = new Integer(128);
Integer e = 128;
Integer f = 128;

System.out.println(a == b);
System.out.println(a.equals(b));

System.out.println(b == c);
System.out.println(b.equals(c));

System.out.println(d == e);
System.out.println(d.equals(e));

System.out.println(e == f);
System.out.println(e.equals(f));
```

Про упаковку (boxing) и распаковку (unboxing) между примитивными типами и эквивалентными классами-обертками, я конечно
знаю, как и про кеширование определенного диапазона значений.
Но вот не припомню, даже за последние 5 лет разработки исключительно на Java, о каком-либо дефекте из-за попытки
сравнения Integer через оператор. А вы встречали такие проблемы на практике?

После указания всей имеющейся вереницы true/false, я озвучил, что не на сто процентов уверен по части числа 128, но,
вроде, кеширование заканчивается на 127. На что собеседующий, с посылом о необходимости знать такие догмы, написал в
блокноте **[-128; 127]**.

Если заглянуть в [спецификацию языка](https://docs.oracle.com/javase/specs/jls/se21/html/index.html), то там можно
найти отдельный
раздел [5.1.7 "Boxing Conversion"](https://docs.oracle.com/javase/specs/jls/se21/html/jls-5.html#jls-5.1.7),
где будет упомянут такой диапазон кеширования для всех целочисленных типов.
Но и обязательные требования, что выходить за рамки данного диапазона недопустимо, отсутствуют. Наоборот там прямо
указывается:

<blockquote class="blockquote">
    Less memory-limited implementations might, for example, cache all char and short values, as well as int and long values in the range of -32K to +32K.
</blockquote>

И вот именно в части Integer окончание диапазона кеширования на 127 уже давно не является догмой. Даже если говорить 
исключительно про OpenJDK и HotSpot JVM, которые принято считать основными реализациями.

Изменить результат сравнения **_e_** и **_f_** для значения 128 можно путем задания
[одной опции JVM](https://github.com/openjdk/jdk/blob/2482a505e5c898cc6365aa4fb8ca3e8b758b3a97/src/java.base/share/classes/java/lang/Integer.java#L964): 

`-Djava.lang.Integer.IntegerCache.high=128`

При этом нижняя граница -128 остается зафиксированной, и не предусмотренно установки верхней границы кеширования менее 127.
Также существует второй вариант указания опции через `-XX:AutoBoxCacheMax`, которая будет иметь приоритет над первой.

Автоматические упаковка и распаковка появились еще в 5 версии Java.
А вот возможность изменения верхней границы кеширования Integer в 1.6.0_14, если верить [журналам изменений](https://www.oracle.com/java/technologies/javase/6u14.html)

Так что, в попытке исключить "рассказывание уже давно написанных ответов", главное не забывать перепроверить актуальность уникальных задач из 2004 года.

P.S. Начиная с 9 версии конструкторы класса Integer помечены @Deprecated.

{{% bs/alert secondary %}}
Источник изображения в заголовке Unsplash. Автор [Steve Johnson](https://unsplash.com/@steve_j).
{{% /bs/alert %}}
